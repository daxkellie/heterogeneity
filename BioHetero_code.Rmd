---
title: "Biological Heterogeneity"
author: "DK"
date: "01/04/2020"
output:
  html_document:
    highlight: pygments
    theme: lumen
    toc: yes
    toc_float: yes
editor_options: 
  chunk_output_type: inline
---

```{r fresh list of bel air, echo = FALSE}
rm(list=ls())
```

```{r packages, message = FALSE, warning = FALSE, error = FALSE}
pacman::p_load(tidyverse, lme4, lmerTest, MuMIn, rstan, brms, rptR, tidybayes, coda,
               sf, "rnaturalearth", "rnaturalearthdata", modelr, ggthemes, ggmcmc, MCMCglmm)

# helping running rstan (brms) models

options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```


# Load Data Sets

```{r}
data_CSV <- read.csv("Datasets/CSV_microcosms/data/milcu_etal2017.csv", header = TRUE)
data_NutNet <- read.csv("Datasets/NutNet/data/Model2.SEM.plot.data.csv", header = TRUE)
data_biomass <- read.csv("Datasets/RichnessDrought/data/biomass_1.2.csv", header = TRUE)
data_BLM <- read.csv("Datasets/BLM/terradat_points_table.csv") # I do not think this is what we want
# more to add here


```


# Nutrient Network (NutNet)
Anderson et al. (2018) model </b>

Test effect of Herbivory (FENCE; yes/no) & Eutrophication (Fertilizer; yes/no) on C, N, P & K

Model includes treatment variable Fence, as well as environmental measures of MAP, MAT and SOLAR.INS  
MAP = mean annual precipitation  
MAT = mean annual temperature  
SOLAR.INS = solar insolation  

Used AIC model comparison to determine final model

```{r}
data_NutNet %>% glimpse()
data_NutNet %>% head(5)
```


Frequency Distribution
```{r}
plot_frequencyDist <- function(df, variable) {
  
  fd.histogram <- ggplot(df, aes_string(x = variable)) + 
    guides(fill = F) # to remove the legend
  
  fd.histogram + 
    geom_histogram(binwidth = .4) + # binwidth tidies the data a bit
    labs(x = variable, y = "Frequency")
  
}
plot_frequencyDist(data_NutNet, "plant.NPK")
plot_frequencyDist(data_NutNet, "plant.N")
plot_frequencyDist(data_NutNet, "plant.P")
plot_frequencyDist(data_NutNet, "plant.K")
```

## Frequentist Model
```{r}
# REPLICATE variable
data_NutNet$REPLICATE <- paste0(data_NutNet$SITE, data_NutNet$TREATMENT)

# Frequentist model
model <- lmer(plant.NPK ~ TREATMENT + (1|SITE) + (1|REPLICATE), data = data_NutNet)
summary(model)
hist(resid(model)) # Note that there is an outlier

# plant N
data_NutNet$log_plant.N <- log(data_NutNet$plant.N) # note - log doesn't fix skew
model <- lmer(log_plant.N ~ TREATMENT + (1|SITE) + (1|REPLICATE), data = data_NutNet)
summary(model)
hist(resid(model)) # Note that there is an outlier

# plant P
model <- lmer(plant.P ~ TREATMENT + (1|SITE) + (1|REPLICATE), data = data_NutNet)
summary(model)
hist(resid(model)) # Note that there is an outlier

# plant K
model <- lmer(plant.K ~ TREATMENT + (1|SITE) + (1|REPLICATE), data = data_NutNet)
summary(model)
hist(resid(model)) # Note that there is an outlier

# total biomass
model <- lmer(TOTAL.AG.BIOMASS ~ TREATMENT + (1|SITE) + (1|REPLICATE), data = data_NutNet)
summary(model)
hist(resid(model)) # Note that there is an outlier

# Total Variance
var(data_NutNet$plant.NPK)
```

**Note:** plant.N & plant.P both have an outlier skewing residuals. plant.K appears normally distributed.




## rptR Repeatability analysis

Plant NPK
```{r}
# Plant NPK
rep_plant.NPK <- rptGaussian(plant.NPK ~ TREATMENT + (1|SITE),
                 grname = c("SITE", "Fixed", "Residual"), 
                 data = data_NutNet,
                 ratio = FALSE,
                 nboot = 100, parallel = TRUE, adjusted = FALSE)

rep_plant.NPK
```

Plant N
```{r}
# Plant N
rep_plant.N <- rptGaussian(plant.N ~ TREATMENT + (1|SITE),
                 grname = c("SITE", "Fixed", "Residual"), 
                 data = data_NutNet,
                 ratio = FALSE,
                 nboot = 100, parallel = TRUE, adjusted = FALSE)

rep_plant.N
```

Plant P
```{r}
# Plant P
rep_plant.P <- rptGaussian(plant.P ~ TREATMENT + (1|SITE),
                 grname = c("SITE", "Fixed", "Residual"), 
                 data = data_NutNet,
                 ratio = FALSE,
                 nboot = 100, parallel = TRUE, adjusted = FALSE)

rep_plant.P
```

Plant K
```{r}
# Plant K
rep_plant.K <- rptGaussian(plant.K ~ TREATMENT + (1|SITE),
                 grname = c("SITE", "Fixed", "Residual"), 
                 data = data_NutNet,
                 ratio = FALSE,
                 nboot = 100, parallel = TRUE, adjusted = FALSE)

rep_plant.K
```

# Total AG Biomass
```{r}
# Total AG Biomass
rep_total.ag.biomass <- rptGaussian(TOTAL.AG.BIOMASS ~ TREATMENT + (1|SITE),
                 grname = c("SITE", "Fixed", "Residual"), 
                 data = data_NutNet,
                 ratio = FALSE,
                 nboot = 100, parallel = TRUE, adjusted = FALSE)

rep_total.ag.biomass
```


### Viz - Variance Components

Pull variance values from rptR output 
```{r}
# Function to pull variance values from rptR output

create_VarTable <- function(repOutput, VariableName, BioHetVariable) {
  
  # retrieve variance values
  varTable <- as.data.frame(repOutput$R)
  
  # make name usable
  VariableName <- as.character(VariableName)
  
  # Pivot table
  varTable <- varTable %>% 
  rename(., Location = paste0(BioHetVariable)) %>% # rename SITE
  mutate(
    Variable = as.factor(paste0(VariableName)) # Add data identifier column
  ) %>%
  pivot_longer(-Variable, names_to = "Components", values_to = "Variance") # flip the table
  
  # add percent of total variance column
  varTable$percentVar <- varTable$Variance/(sum(varTable$Variance))*100
  
  return(varTable)
}
```

Create tables with variance values
```{r}

varTable_plant.NPK <- create_VarTable(rep_plant.NPK, "plant.NPK", "SITE")
varTable_plant.N <- create_VarTable(rep_plant.N, "plant.N", "SITE")
varTable_plant.P <- create_VarTable(rep_plant.P, "plant.P", "SITE")
varTable_plant.K <- create_VarTable(rep_plant.K, "plant.K", "SITE")
varTable_total.ag.biomass <- create_VarTable(rep_total.ag.biomass, "total.ag.biomass", "SITE")

# Create 
varTable_NutNet <- rbind(varTable_plant.N, 
                         varTable_plant.P, varTable_plant.K,
                         varTable_total.ag.biomass)
```

*Plot*
```{r}
library(forcats)
library(ggthemes)

varTable_NutNet %>%
  mutate(Components = fct_relevel(Components, 
                                  "Fixed", "Residual", "Location")) %>%
  
  ggplot(aes(x = Variable, y = percentVar, fill = Components)) + 
  geom_bar(stat = "identity", position = "stack", width = .4) +
  geom_text(aes(label = paste0(round(percentVar, 0), "%")), 
            position = "stack", hjust = 1, size = 2, check_overlap = FALSE) + 
    scale_fill_ptol() + 
    coord_flip() + 
  ylab("Proportion of Variance (%)") + 
    theme_minimal(base_size = 12)
    theme(axis.title = element_blank(), panel.grid.major.y = element_blank(), 
          legend.position = "top")

```

## Bayesian Model
```{r, eval = FALSE}
# Bayesian models
# NPK
# modelb_plant.NPK <- brm(plant.NPK ~ TREATMENT + (1|SITE) + (1|REPLICATE), 
#                         data = data_NutNet,
#                         chains = 2, cores = 2) # you can do more but 2 chains will be fine
# N
# modelb_plant.N <- brm(plant.N ~ TREATMENT + (1|SITE) + (1|REPLICATE), 
#                         data = data_NutNet,
#                         chains = 2, cores = 2)
# P
# modelb_plant.P <- brm(plant.P ~ TREATMENT + (1|SITE) + (1|REPLICATE), 
#                         data = data_NutNet,
#                         chains = 2, cores = 2)
# K
# modelb_plant.K <- brm(plant.K ~ TREATMENT + (1|SITE) + (1|REPLICATE), 
#                         data = data_NutNet,
#                         chains = 2, cores = 2)
# # K
# modelb_total.ag.biomass <- brm(TOTAL.AG.BIOMASS ~ TREATMENT + (1|SITE) + (1|REPLICATE),
#                         data = data_NutNet,
#                         chains = 2, cores = 2)

# Save models
# saveRDS(modelb_plant.NPK, "model_plantNPK.rds")
# saveRDS(modelb_plant.N, "model_plantN.rds")
# saveRDS(modelb_plant.P, "model_plantP.rds")
# saveRDS(modelb_plant.K, "model_plantK.rds")
# saveRDS(modelb_total.ag.biomass, "model_total.ag.biomass.rds")
```


```{r}
# Load models
modelb_plant.NPK <- readRDS("model_plantNPK.rds")
modelb_plant.N <- readRDS("model_plantN.rds")
modelb_plant.P <- readRDS("model_plantP.rds")
modelb_plant.K <- readRDS("model_plantK.rds")
modelb_total.ag.biomass <- readRDS("model_total.ag.biomass.rds")

summary(modelb_plant.NPK)
bayes_R2(modelb_plant.NPK)
bayes_R2(modelb_plant.N)
bayes_R2(modelb_plant.P)
bayes_R2(modelb_plant.K)
bayes_R2(modelb_total.ag.biomass)
```


```{r}
ggplot(data  = data_NutNet,
       aes(x = TREATMENT,
           y = TOTAL.AG.BIOMASS,
           colour = TREATMENT))+
  geom_point(size = 1.2,
             alpha = .8,
             position = "jitter")+# to add some random noise for plotting purposes
  theme_minimal() + theme(legend.position = "none")
```

```{r}
get_variables(modelb_plant.NPK)
```

```{r}
library(ggmcmc)

model1transformed <- ggs(modelb_plant.NPK)
ggplot(filter(model1transformed, Parameter %in% c("b_Intercept", "sigma", "r_SITE[burrawan.au,Intercept]")),
       aes(x   = Iteration,
           y   = value, 
           col = as.factor(Chain)))+
  geom_line() +
  geom_vline(xintercept = 1000)+
  facet_grid(Parameter ~ . ,
             scale  = 'free_y',
             switch = 'y')+
  labs(title = "Caterpillar Plots", 
       col   = "Chains")
```

```{r}
modelb_plant.NPK %>%
  spread_draws(b_Intercept, r_SITE[location,]) %>%
  median_qi(location_mean = b_Intercept + r_SITE) %>%
  ggplot(aes(y = location, x = location_mean, xmin = .lower, xmax = .upper)) +
  geom_pointintervalh()
```

```{r}
library(modelr)

# data_NutNet %>%
#   data_grid(SITE) %>%
#   add_predicted_draws(modelb_plant.NPK) %>%
#   ggplot(aes(x = .prediction, y = R_SITE)) +
#   stat_slabh()
```


##### Plant NPK
```{r}
# getting posterior of random effects for each
# blups <- ranef(modelb, summary = F) # WHAT IS THIS DO I NEED IT

# get all posterior samples
post <- posterior_samples(modelb_plant.NPK)
names(post)

# these three are important
# [1] "b_Intercept"                                  "b_TREATMENTFence"                            
#  [3] "b_TREATMENTNPK"                               "b_TREATMENTNPK_Fence"                        
#  [5] "sd_REPLICLATE__Intercept"                     "sd_SITE__Intercept"                          
#  [7] "sigma"         

# we get what we need - for random effect
V_rep <-post$sd_REPLICATE__Intercept^2 # making it variance
V_site <-post$sd_SITE__Intercept^2
V_res <- post$sigma^2 
    # Why is sigma equal to residual variance? 
    # Don't we need sigma to calculate error of estimates in plots?
```


```{r}
# we need to calculate variance for fixed effects - this is not so easy
# get a posterior for fixed effect bits (you need to get this as one - it will be difficult to decompose these - why?)
# I cannot seem to get a model matrix from brms so I am going to use lmer

# get a data frame of different posterior of fixed effects
post_fix <- as.data.frame(t(post[,1:4]))

# get a posterior of fixed effects
V_fix <-  map_dbl(post_fix, ~ var(as.vector(. %*% t(model@pp$X))) )

# mcmc object (from coda package)
post_mat <- as.mcmc(data.frame(V_rep, V_site, V_res, V_fix, row.names = NULL))

summary(post_mat)
plot(post_mat)

head(post_mat)

post_mat %>% data.frame %>% mutate(V_all = V_rep + V_site + V_res + V_fix,
                                   P_rep = V_rep/(V_rep + V_site + V_res + V_fix),
                                   P_site = V_site/(V_rep + V_site + V_res + V_fix),
                                   P_res = V_res/(V_rep + V_site + V_res + V_fix),
                                   P_fix = V_fix/(V_rep + V_site + V_res + V_fix),
                                   P_all = P_rep + P_site + P_res + P_fix)          ->  post_mat2_plant.NPK

```

##### Plant N

```{r}
# get all posterior samples
post <- posterior_samples(modelb_plant.N)

# we get what we need - for random effect
V_rep <-post$sd_REPLICATE__Intercept^2 # making it variance
V_site <-post$sd_SITE__Intercept^2
V_res <- post$sigma^2 
```


```{r}
# calculate variance for fixed effects

# get a data frame of different posterior of fixed effects
post_fix <- as.data.frame(t(post[,1:4]))

# get a posterior of fixed effects
V_fix <-  map_dbl(post_fix, ~ var(as.vector(. %*% t(model@pp$X))) )

# mcmc object (from coda package)
post_mat <- as.mcmc(data.frame(V_rep, V_site, V_res, V_fix, row.names = NULL))

summary(post_mat)
plot(post_mat)

head(post_mat)

post_mat %>% data.frame %>% mutate(V_all = V_rep + V_site + V_res + V_fix,
                                   P_rep = V_rep/(V_rep + V_site + V_res + V_fix),
                                   P_site = V_site/(V_rep + V_site + V_res + V_fix),
                                   P_res = V_res/(V_rep + V_site + V_res + V_fix),
                                   P_fix = V_fix/(V_rep + V_site + V_res + V_fix),
                                   P_all = P_rep + P_site + P_res + P_fix)          ->  post_mat2_plant.N

```

#### Plant P
```{r}
# get all posterior samples
post <- posterior_samples(modelb_plant.P)

# we get what we need - for random effect
V_rep <-post$sd_REPLICATE__Intercept^2 # making it variance
V_site <-post$sd_SITE__Intercept^2
V_res <- post$sigma^2 
```


```{r}
# calculate variance for fixed effects

# get a data frame of different posterior of fixed effects
post_fix <- as.data.frame(t(post[,1:4]))

# get a posterior of fixed effects
V_fix <-  map_dbl(post_fix, ~ var(as.vector(. %*% t(model@pp$X))) )

# mcmc object (from coda package)
post_mat <- as.mcmc(data.frame(V_rep, V_site, V_res, V_fix, row.names = NULL))

summary(post_mat)
plot(post_mat)

head(post_mat)

post_mat %>% data.frame %>% mutate(V_all = V_rep + V_site + V_res + V_fix,
                                   P_rep = V_rep/(V_rep + V_site + V_res + V_fix),
                                   P_site = V_site/(V_rep + V_site + V_res + V_fix),
                                   P_res = V_res/(V_rep + V_site + V_res + V_fix),
                                   P_fix = V_fix/(V_rep + V_site + V_res + V_fix),
                                   P_all = P_rep + P_site + P_res + P_fix)          ->  post_mat2_plant.P

```


#### Plant K
```{r}
# get all posterior samples
post <- posterior_samples(modelb_plant.K)

# we get what we need - for random effect
V_rep <-post$sd_REPLICATE__Intercept^2 # making it variance
V_site <-post$sd_SITE__Intercept^2
V_res <- post$sigma^2 
```


```{r}
# calculate variance for fixed effects

# get a data frame of different posterior of fixed effects
post_fix <- as.data.frame(t(post[,1:4]))

# get a posterior of fixed effects
V_fix <-  map_dbl(post_fix, ~ var(as.vector(. %*% t(model@pp$X))) )

# mcmc object (from coda package)
post_mat <- as.mcmc(data.frame(V_rep, V_site, V_res, V_fix, row.names = NULL))

summary(post_mat)
plot(post_mat)

head(post_mat)

post_mat %>% data.frame %>% mutate(V_all = V_rep + V_site + V_res + V_fix,
                                   P_rep = V_rep/(V_rep + V_site + V_res + V_fix),
                                   P_site = V_site/(V_rep + V_site + V_res + V_fix),
                                   P_res = V_res/(V_rep + V_site + V_res + V_fix),
                                   P_fix = V_fix/(V_rep + V_site + V_res + V_fix),
                                   P_all = P_rep + P_site + P_res + P_fix)          ->  post_mat2_plant.K

```

```{r}
# get all posterior samples
post <- posterior_samples(modelb_plant.K)

# we get what we need - for random effect
V_rep <-post$sd_REPLICATE__Intercept^2 # making it variance
V_site <-post$sd_SITE__Intercept^2
V_res <- post$sigma^2 
```


```{r}
# calculate variance for fixed effects

# get a data frame of different posterior of fixed effects
post_fix <- as.data.frame(t(post[,1:4]))

# get a posterior of fixed effects
V_fix <-  map_dbl(post_fix, ~ var(as.vector(. %*% t(model@pp$X))) )

# mcmc object (from coda package)
post_mat <- as.mcmc(data.frame(V_rep, V_site, V_res, V_fix, row.names = NULL))

summary(post_mat)
plot(post_mat)

head(post_mat)

post_mat %>% data.frame %>% mutate(V_all = V_rep + V_site + V_res + V_fix,
                                   P_rep = V_rep/(V_rep + V_site + V_res + V_fix),
                                   P_site = V_site/(V_rep + V_site + V_res + V_fix),
                                   P_res = V_res/(V_rep + V_site + V_res + V_fix),
                                   P_fix = V_fix/(V_rep + V_site + V_res + V_fix),
                                   P_all = P_rep + P_site + P_res + P_fix)          ->  post_mat2_plant.K

```


### Viz - Variance Components
```{r}
# Function to create data frames
create_bayesVarTable <- function(posteriorVarianceDF, variableName) {
  # make variable name usable for character
  varName <- as.character(variableName)
  
  # build data frame
  dataFrame <- posteriorVarianceDF %>% 
  mutate(
    iteration = 1:length(post_mat2_plant.NPK$P_all), # make a col to represent each test
    Variable = as.factor(paste(variableName))         # add Variable name
  ) %>%
  select(P_rep, P_site, P_res, P_fix, iteration, Variable) %>%
  pivot_longer(c(-Variable, -iteration), values_to = "Variance") # flip the table
}

propPost_plant.NPK <- create_bayesVarTable(post_mat2_plant.NPK, "plant.NPK")
propPost_plant.N <- create_bayesVarTable(post_mat2_plant.N, "plant.N")
propPost_plant.P <- create_bayesVarTable(post_mat2_plant.P, "plant.P")
propPost_plant.K <- create_bayesVarTable(post_mat2_plant.K, "plant.K")


# Combine
propPost <- as.data.frame(rbind(propPost_plant.N, propPost_plant.P, propPost_plant.K))




str(post_mat2_plant.N)
str(propPost)

# finding average proportions of all variables
mean_P_rep <- ((post_mat2_plant.N$P_rep + post_mat2_plant.P$P_rep + post_mat2_plant.K$P_rep)/3)
mean_P_site <- ((post_mat2_plant.N$P_site + post_mat2_plant.P$P_site + post_mat2_plant.K$P_site)/3)
mean_P_res <- ((post_mat2_plant.N$P_res + post_mat2_plant.P$P_res + post_mat2_plant.K$P_res)/3)
mean_P_fix <- ((post_mat2_plant.N$P_fix + post_mat2_plant.P$P_fix + post_mat2_plant.K$P_fix)/3)

propPost_NutNet <- as.data.frame(cbind(mean_P_rep, mean_P_site, mean_P_res, mean_P_fix))


# Summarised SE & mean values
propPost.sem <- propPost %>% 
  group_by(Variable, name) %>% 
  summarise(mean = mean(Variance),
            sem = sd(Variance) / sqrt(n()),
            lower = (mean - sem),
            upper = (mean + sem))
str(propPost.sem)
```


```{r}
# Dax to make figure
library(ggthemes)

propPost %>%
    mutate(
    name = as.factor(recode(name,
                        "P_fix" = "Fixed",
                        "P_rep" = "Replicate",
                        "P_res" = "Residual",
                        "P_site" = "Location"))
  ) %>%
  ggplot(aes(x = name, y = Variance, fill = name, colour = name)) + 
  facet_grid(~Variable) +
  stat_summary(fun.y = mean, geom = "bar", position = "dodge",width = 1, alpha = .8) +
  stat_summary(fun.data = mean_cl_normal, geom = "errorbar", 
               width = 0.15, position = position_dodge(width = 0.90), colour = "black") +
  # geom_bar(stat = "identity", position = "stack", width = 0.2, alpha = .6, size = 1) +
  # geom_errorbar(aes(ymin = lower, 
  #                   ymax = upper),
  #               stat = "identity",
  #               width=.1,                    # Width of the error bars
  #               position="identity", colour = "black") + 
  coord_cartesian(ylim = c(0, 1)) + 
  scale_y_continuous(labels = scales::percent) +
  labs(x = "Variance Components",
       y = "Proportion of Total Variance") +
  scale_fill_ptol() + scale_colour_ptol() + 
  theme_minimal() + 
  theme(legend.position = "none")


# Dax - go to here (not all exp and code are useful)
# https://github.com/paul-buerkner/brms
# https://mjskay.github.io/tidybayes/articles/tidy-brms.html
# https://www.rensvandeschoot.com/tutorials/brms-started/
# and learn and do more exploration with this and other ones

library(MCMCglmm)
mean(V_rep) # this is posterior mean (variance of random effect estimate)
posterior.mode(V_rep) # posterior mode because variation is not normally distributed

# post_mat note:
#   posterior should add up to one

```




# Controlled Systematic Variability (CSV)
Microcosms experiment  
Milcu et al. (2018)  
Sites: 14 European Labs  

<br/>

Tested effect of presence of legume species on grass species. Introducted genetic and environmental variability.  <br/>

Rename columns
```{r}
data_CSV <- rename(data_CSV,
                   Legume = Treat..legume.,
                   CSV = Treat..controlled.systematic.variabiliy.,
                   biomass_Seed = Biom.dm..g...seed.,
                   biomass_Shoot = Biom.dm..g...shoot.,
                   biomass_Root = Biom.dm..g...root.,
                   biomass_Total = Biom.dm..g...total.,
                   ratio_RootShoot = Root.shoot,
                   N.shoot = N.shoot....,
                   C.shoot = C.shoot....
                   )

# They removed outliers but I'll keep these in.
```

```{r}
data_CSV %>% glimpse()
data_CSV %>% head(10)
```


## Repeatability Analysis

Shinichi's model
```{r}
data_CSV$Replicate <-  paste0(data_CSV$Block, data_CSV$Lab) # add replicate variable

model <- lmer(biomass_Seed ~ Legume*Method.comm + (1|Lab) + (1|CSV)+
                (1| Replicate), 
                data = data_CSV)
                
summary(model)                
```
Frequency distribution of data
```{r}
plot_frequencyDist(data_CSV, "biomass_Seed")
plot_frequencyDist(data_CSV, "biomass_Seed")
```

## rptR Repeatability Analysis
_Use the buttons to navigate_

### Seed Biomass
```{r}
rep_biomass_Seed <- rptGaussian(biomass_Seed ~ Legume*Method.comm + (1|Lab) + (1|CSV) + (1| Replicate),
                    grname = c("Lab", "CSV", "Replicate", "Fixed", "Residual"), 
                    data = data_CSV,
                    ratio = FALSE,
                    nboot = 100, parallel = TRUE, adjusted = FALSE)

rep_biomass_Seed
```

### Shoot Biomass
```{r}
rep_biomass_Shoot <- rptGaussian(biomass_Shoot ~ Legume*Method.comm + (1|Lab) + (1|CSV) + (1| Replicate),
                    grname = c("Lab", "CSV", "Replicate", "Fixed", "Residual"), 
                    data = data_CSV,
                    ratio = FALSE,
                    nboot = 10, parallel = FALSE, adjusted = FALSE)
rep_biomass_Shoot
```

### Root Biomass
```{r}
rep_biomass_Root <- rptGaussian(biomass_Root ~ Legume*Method.comm + (1|Lab) + (1|CSV) + (1| Replicate),
                    grname = c("Lab", "CSV", "Replicate", "Fixed", "Residual"), 
                    data = data_CSV,
                    ratio = FALSE,
                    nboot = 100, parallel = TRUE, adjusted = FALSE)
rep_biomass_Root
```

### Total Biomass
```{r}
rep_biomass_Total <- rptGaussian(biomass_Total ~ Legume*Method.comm + (1|Lab) + (1|CSV) + (1| Replicate),
                    grname = c("Lab", "CSV", "Replicate", "Fixed", "Residual"), 
                    data = data_CSV,
                    ratio = FALSE,
                    nboot = 100, parallel = TRUE, adjusted = FALSE)
rep_biomass_Total
```

### Root:Shoot Ratio
```{r}
rep_ratio_RootShoot <- rptGaussian(ratio_RootShoot ~ Legume*Method.comm + 
                                     (1|Lab) + (1|CSV) + (1| Replicate),
                    grname = c("Lab", "CSV", "Replicate", "Fixed", "Residual"), 
                    data = data_CSV,
                    ratio = FALSE,
                    nboot = 100, parallel = TRUE, adjusted = FALSE)
rep_ratio_RootShoot
```

### N Shoot
```{r}
rep_N.shoot <- rptGaussian(N.shoot ~ Legume*Method.comm + (1|Lab) + (1|CSV) + (1| Replicate),
                    grname = c("Lab", "CSV", "Replicate", "Fixed", "Residual"), 
                    data = data_CSV,
                    ratio = FALSE,
                    nboot = 100, parallel = TRUE, adjusted = FALSE)
rep_N.shoot
```

### C Shoot
```{r}
rep_C.shoot <- rptGaussian(C.shoot ~ Legume*Method.comm + (1|Lab) + (1|CSV) + (1| Replicate),
                    grname = c("Lab", "CSV", "Replicate", "Fixed", "Residual"), 
                    data = data_CSV,
                    ratio = FALSE,
                    nboot = 100, parallel = TRUE, adjusted = FALSE)
rep_C.shoot
```

## Data Viz - Variance Components

Pull variance values from rptR output & Create table with variance components
```{r}

varTable_biomass_Seed <- create_VarTable(rep_biomass_Seed, "biomass_Seed", "Lab")
varTable_biomass_Shoot <- create_VarTable(rep_biomass_Shoot, "biomass_Shoot", "Lab")
varTable_biomass_Root <- create_VarTable(rep_biomass_Root, "biomass_Root", "Lab")
varTable_biomass_Total <- create_VarTable(rep_biomass_Total, "biomass_Total", "Lab")
varTable_ratio_RootShoot <- create_VarTable(rep_ratio_RootShoot, "ratio_RootShoot", "Lab")
varTable_N.shoot <- create_VarTable(rep_N.shoot, "N.shoot", "Lab")
varTable_C.shoot <- create_VarTable(rep_C.shoot, "C.shoot", "Lab")


# Create table
varTable_CSV <- rbind(varTable_biomass_Seed, varTable_biomass_Shoot, 
                      varTable_biomass_Root, varTable_biomass_Total,
                      varTable_ratio_RootShoot, varTable_N.shoot,
                      varTable_C.shoot)
```

*Plot*
```{r}
library(forcats)

varTable_CSV %>%
  mutate(Components = fct_relevel(Components,
                                  "Fixed", "Replicate", "CSV", "Residual", "Location")) %>%
  
  ggplot(aes(x = Variable, y = percentVar, fill = Components)) + 
  geom_bar(stat = "identity", position = "stack", width = .4) +
  geom_text(aes(label = paste0(round(percentVar, 0), "%")), 
            position = "stack", hjust = 1, size = 2, check_overlap = FALSE) + 
    scale_fill_ptol() + 
    coord_flip() + 
  ylab("Proportion of Variance (%)") + 
    theme_minimal(base_size = 12) 
    theme(axis.title = element_blank(), panel.grid.major.y = element_blank(), 
          legend.position = "top")

```






# BLM Data
Bureau of Land Management data

```{r}
data_BLM %>% glimpse()
data_BLM %>% head(5)
dim(data_BLM)
```

```{r}
library(sf)
library("rnaturalearth")
library("rnaturalearthdata")

world <- ne_countries(scale = "medium", returnclass = "sf")
library(tidyverse)
ggplot(data = world) +
    geom_sf() +
    geom_point(data = data_BLM, aes(x = Longitude, y = Latitude), size = 1, 
               shape = 21, fill = "red") +
    coord_sf(xlim = c(-180, 120), ylim = c(-80, 80), expand = FALSE) + 
  theme_bw()

```



## Example Model for Dax

Dax says:

__ProjectName__: Refers to the broader project area the data was collected in. Generally includes the state, BLM management office and year.
(what Tim says we can treat as our "site/location" variable)
__PlotID__: Name for each location or "plot" where data is collected, as assigned by the data collector. Duplicate Plot ID's may exist among different Sites and Projects, but not within the same Site.
(So each PlotID is unique)
__PlotKey__: Unique numeric ID associated with each plot location. This is automatically generated in DIMA the first time the plot is created. Future visits to the same plot might use the same PlotKey. Users are encouraged to use spatial joins to track trend over time.
(So sometimes, but not always, there may be multiple years of data for a plot location, which is tracked using this variable)

<!-- Note: OK - this is good but I now see we need to recode PlotID to use this (so we cannot use PlotID as they as when we fit in the mixed model (very much like we did for other datasets. -->

```{r}
# transforming some of the data
# one problem I see is that soil stablity seems like a maesurement 0 - 6 (how this is determined - some sort of artificial scale???)
hist(data_BLM$SoilStability_All)
hist(data_BLM$SoilStability_Protected)
hist(data_BLM$NonInvPerenGrassCover_AH)

# just creating a smaller data set for me for a test
dim(data_BLM)
sum(complete.cases(data_BLM)) # OK this loses a lot of data

```

```{r}
# Add Year to its own column
list_years <- c("2000", "2001", "2002", "2003", "2004", 
                "2005", "2006", "2007", "2008", "2009", 
                "2010", "2011", "2012", "2013", "2014", 
                "2015", "2016", "2017", "2018", "2019")

data_BLM <- map_df(list_years, ~ filter(data_BLM, str_detect(ProjectName, .x)) %>%
                    mutate(Year = str_extract(ProjectName, .x)))

# Removing year from ProjectName
data_BLM <- data_BLM %>%
  mutate(
    ProjectName = as.factor(gsub("([0-9]+).*$", "", ProjectName))
  )


# Create replicate variable
data_BLM$Replicate <-  paste0(data_BLM$ProjectName, data_BLM$Year)
```


```{r}
# we should get the total variance of 1
data_BLM %>% mutate(z_soil_stab = scale(SoilStability_All), z_non_inv_cover = scale(NonInvPerenGrassCover_AH)) %>% select(ProjectName, Replicate, z_soil_stab, z_non_inv_cover) -> sdata_BLM

sdata_BLM <- sdata_BLM[complete.cases(sdata_BLM), ]

# random slope model
model <- lmer(z_soil_stab ~ z_non_inv_cover + (1 + z_non_inv_cover|ProjectName), 
              data = sdata_BLM)
summary(model)
hist(resid(model)) # Looks great

# random intercept model
model0 <- lmer(z_soil_stab ~ z_non_inv_cover + (1 |ProjectName) + (1 | Replicate), 
               data = sdata_BLM)
summary(model0)
hist(resid(model0)) 

# model for Dax
# random slope model
model <- lmer(z_soil_stab ~ z_non_inv_cover + (1 + z_non_inv_cover|ProjectName) + (1 | Replicate), 
              data = sdata_BLM)
summary(model)
hist(resid(model)) # Looks great


```

## Bayesian Model
```{r}
# Soil Stability
modelb_soil_stab <- brm(z_soil_stab ~ z_non_inv_cover + 
                          (1 + z_non_inv_cover|ProjectName) + (1 | Replicate),
                        data = sdata_BLM,
                        chains = 2, cores = 2) # you can do more but 2 chains will be fine

# Save models
saveRDS(modelb_soil_stab, "modelb_soil_stab.rds")

```

```{r}
# Load models
modelb_soil_stab <- readRDS("modelb_soil_stab.rds")
```





# Biodiversity x Drought
```{r}
data_biomass %>% glimpse()
data_biomass %>% head(5)
```


# Replicated Models from Papers

## Anderson et al. (2018)
They use Log Response Ratio of total NPK between Control & Fertilizer treatment as Dependent Variable
```{r}
# get sum of DV
table_NPK_Fert <- data_NutNet %>% 
  group_by(SITE, NPK.ADDED, FENCE, MAP, MAT, SOLAR.INS, N.DEPOSITION) %>% 
  select(SITE, NPK.ADDED, plant.NPK, plant.N, plant.P, plant.K) %>%
  summarise(total.NPK = sum(plant.NPK))

# Prepare table for pivot_wider()
table_NPK_Fert$NPK.ADDED <- as.character(table_NPK_Fert$NPK.ADDED)
table_NPK_Fert$NPK.ADDED <- recode(table_NPK_Fert$NPK.ADDED, "0" = "Control", '1' = "Fertilizer")

# Calulate Log Response Ratio of DV (Control vs Fertilizer effect)
table_NPK_Fert <- 
  table_NPK_Fert %>% 
  pivot_wider(names_from = NPK.ADDED, values_from = total.NPK) %>%
  group_by(SITE) %>%
  mutate(
    LRR_Fertilizer = log(Fertilizer/Control)
  )
```

```{r}
# Anderson et al. model
model <- lm(LRR_Fertilizer ~ FENCE + MAT + MAT + SOLAR.INS + N.DEPOSITION + FENCE:MAT, 
              data = table_NPK_Fert)

anova(model)
summary(model)
```



## Milcu et al. (2018)
#### Their model
```{r}
model <- lmer(biomass_Seed ~ Legume * Lab * CSV + 
                (1|Block/Method.comm), 
                data = data_CSV)
```
